This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-02-08T18:17:03.933Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
ConsumableItemData.cs
ConsumableItemData.cs.meta
DayandNight.cs
DayandNight.cs.meta
GroundItem.cs
GroundItem.cs.meta
InputManager.cs
InputManager.cs.meta
Inventory.cs
Inventory.cs.meta
InventoryItem.cs
InventoryItem.cs.meta
InventoryItemData.cs
InventoryItemData.cs.meta
InventoryManger.cs
InventoryManger.cs.meta
InventorySlot.cs
InventorySlot.cs.meta
PlayerController.cs
PlayerController.cs.meta
PlayerStats.cs
PlayerStats.cs.meta
StatsBar.cs
StatsBar.cs.meta

================================================================
Files
================================================================

================
File: ConsumableItemData.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
[CreateAssetMenu(menuName = "Scriptable Objects/ConsumableItem")]
public class ConsumableItemData : InventoryItemData
{
	public float healthRestore;
	public float hungerRestore;
	public float thirstRestore;
}

================
File: ConsumableItemData.cs.meta
================
fileFormatVersion: 2
guid: eb9f6f49eb2671446a3d5f9badde89a7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DayandNight.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DayAndNightCycle : MonoBehaviour
{
    //variable to store a light source
    [SerializeField] private Light sun;

    //variable to store the time of the day
    [SerializeField, Range(0, 24)] private float timeOfDay;

    //variable to store the speed of rotation
    [SerializeField] private float sunRotationSpeed;

    //variables to store the lighting presets
    [Header("LightingPreset")]
    [SerializeField] private Gradient skyColor;

    [SerializeField] private Gradient equatorColor;
    [SerializeField] private Gradient sunColor;
    //function to update Sun's rotation

    private void Update()
    {
        timeOfDay += Time.deltaTime * sunRotationSpeed;
        if (timeOfDay > 24)
            timeOfDay = 0;
        UpdateSunRotation();
        UpdateLighting();
    }

    private void OnValidate()
    {
        UpdateSunRotation();
        UpdateLighting();
    }

    private void UpdateSunRotation()
    {
        float sunRotation = Mathf.Lerp(-90, 270, timeOfDay / 24);
        sun.transform.rotation = Quaternion.Euler(sunRotation, sun.transform.rotation.y, sun.transform.rotation.z);
    }

    //fuction to update the lighting

    private void UpdateLighting()
    {
        float timeFraction = timeOfDay / 24;
        RenderSettings.ambientEquatorColor = equatorColor.Evaluate(timeFraction);
        RenderSettings.ambientSkyColor = skyColor.Evaluate(timeFraction);
        sun.color = sunColor.Evaluate(timeFraction);
    }
}

================
File: DayandNight.cs.meta
================
fileFormatVersion: 2
guid: 140cedc274fbda94bba0821f86ebd44a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: GroundItem.cs
================
using UnityEngine;

public class GroundItem : MonoBehaviour
{
	// Reference to the InventoryItem ScriptableObject representing this item.
	public InventoryItemData item;

	private void OnTriggerEnter(Collider other)
	{

		if (other.CompareTag("Player"))
		{
			InventoryManager inventoryUI = other.GetComponent<InventoryManager>();
			if (inventoryUI != null && item != null)
			{
				// Add the item to the extended inventory (or hotbar, as you prefer).
				inventoryUI.AddItem(item);
				Destroy(gameObject);
			}
		}
	}
}

================
File: GroundItem.cs.meta
================
fileFormatVersion: 2
guid: a3c5436112fc28d499b22535f4de962b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: InputManager.cs
================
using System;
using UnityEngine;

public class InputManager : MonoBehaviour
{
	[SerializeField] private float mouseSensitivity = 10f;

	public Vector2 GetMovementInput()
	{
		float horizontal = Input.GetAxisRaw("Horizontal");
		float vertical = Input.GetAxisRaw("Vertical");
		return new Vector2(horizontal, vertical);
	}

	public bool GetJumpInput()
	{
		return Input.GetButtonDown("Jump");
	}

	public Vector2 GetMouseLookInput()
	{
		float mouseX = Input.GetAxis("Mouse X") * mouseSensitivity;
		float mouseY = Input.GetAxis("Mouse Y") * mouseSensitivity;
		return new Vector2(mouseX, mouseY);
	}

	public int GetHotbarSlotInput()
	{
		// Check keys 1-9 (which map to slot indices 0â€“8)
		for (int i = 1; i <= 9; i++)
		{
			if (Input.GetKeyDown(i.ToString()))
			{
				return i - 1; // convert to 0-indexed
			}
		}
		// Check key "0" for the tenth slot (index 9)
		if (Input.GetKeyDown(KeyCode.Alpha0))
		{
			return 9;
		}
		return -1;
	}

	public bool GetInventoryInput()
	{
		return Input.GetKeyDown(KeyCode.I);
	}
	public bool GetUseInput()
	{
		return Input.GetMouseButtonDown(0);
	}

}

================
File: InputManager.cs.meta
================
fileFormatVersion: 2
guid: 38c6ea6a996af4a44b09d483432f21a8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Inventory.cs
================
using System;

public class Inventory
{
	private InventoryItemData[] items;
	private int totalSize;
	private int hotbarSize;

	public event Action OnInventoryChanged;

	public Inventory(int totalSize, int hotbarSize)
	{
		this.totalSize = totalSize;
		this.hotbarSize = hotbarSize;
		items = new InventoryItemData[totalSize];
	}

	public bool TryAddItem(InventoryItemData newItem)
	{
		// Fill hotbar indices first
		for (int i = 0; i < hotbarSize; i++)
		{
			if (items[i] == null)
			{
				items[i] = newItem;
				OnInventoryChanged?.Invoke();
				return true;
			}
		}
		for (int i = hotbarSize; i < totalSize; i++)
		{
			if (items[i] == null)
			{
				items[i] = newItem;
				OnInventoryChanged?.Invoke();
				return true;
			}
		}
		return false;
	}

	public InventoryItemData GetItem(int index)
	{
		if (index < 0 || index >= totalSize) return null;
		return items[index];
	}

	public void SetItem(int index, InventoryItemData data)
	{
		if (index < 0 || index >= totalSize) return;
		items[index] = data;
		OnInventoryChanged?.Invoke();
	}

	public void SwapItems(int indexA, int indexB)
	{
		if (indexA < 0 || indexA >= totalSize) return;
		if (indexB < 0 || indexB >= totalSize) return;
		var temp = items[indexA];
		items[indexA] = items[indexB];
		items[indexB] = temp;
		OnInventoryChanged?.Invoke();
	}
	public void RemoveItem(int index)
	{
		if (index < 0 || index >= totalSize) return;
		items[index] = null;
		OnInventoryChanged?.Invoke();
	}

	public int TotalSize => totalSize;
	public int HotbarSize => hotbarSize;
}

================
File: Inventory.cs.meta
================
fileFormatVersion: 2
guid: b2f5b7180d17f0a46a7e9902b5a0a509
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: InventoryItem.cs
================
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

public class InventoryItem : MonoBehaviour,
	IBeginDragHandler, IDragHandler, IEndDragHandler
{
	public InventoryItemData itemData;
	public Image itemIcon;
	public CanvasGroup canvasGroup;
	public Transform originalParent;

	void Awake()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		itemIcon = GetComponent<Image>();
	}

	public void Initialize(InventoryItemData data)
	{
		itemData = data;
		if (itemIcon != null && data != null)
		{
			itemIcon.sprite = data.itemIcon;
			itemIcon.enabled = (data.itemIcon != null);
			// Make sure preserveAspect is on so it fits the slot better
			itemIcon.preserveAspect = true;
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		originalParent = transform.parent;
		transform.SetParent(transform.root);
		transform.SetAsLastSibling();
		if (canvasGroup != null)
			canvasGroup.blocksRaycasts = false;
	}

	public void OnDrag(PointerEventData eventData)
	{
		transform.position = Input.mousePosition;
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		if (canvasGroup != null)
			canvasGroup.blocksRaycasts = true;

		// Check if dropped on a slot
		GameObject pointerObj = eventData.pointerCurrentRaycast.gameObject;
		if (pointerObj != null)
		{
			InventorySlot slot = pointerObj.GetComponent<InventorySlot>();
			if (slot != null)
			{
				slot.PlaceItem(this);
				return;
			}
		}

		// Otherwise snap back
		ReturnToOriginalSlot();
	}

	private void ReturnToOriginalSlot()
	{
		transform.SetParent(originalParent, false);
		transform.localPosition = Vector3.zero;
	}
}

================
File: InventoryItem.cs.meta
================
fileFormatVersion: 2
guid: 5b0673a03f4b9514e8e20a2e13161114
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: InventoryItemData.cs
================
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
[CreateAssetMenu(menuName = "Scriptable Objects/InventoryItem")]
public class InventoryItemData : ScriptableObject
{
	public string itemName;
	public string itemDescription;
	public Sprite itemIcon;
	public GameObject itemPrefab;
}

================
File: InventoryItemData.cs.meta
================
fileFormatVersion: 2
guid: 03fe39fc279f52047af86bb9ed0574c3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: InventoryManger.cs
================
using UnityEngine;
using UnityEngine.UI;

public class InventoryManager : MonoBehaviour
{
	[SerializeField] private InventoryItemData[] startingItems;

	private InventorySlot[] hotbarSlots;
	private InventorySlot[] extendedSlots;
	private GameObject extendedPanel;
	private int selectedHotbarSlot = -1;

	private Inventory inventory;
	private const int HOTBAR_COUNT = 10;
	private const int EXTENDED_COUNT = 24;

	public void InitializeInventoryUI()
	{
		inventory = new Inventory(HOTBAR_COUNT + EXTENDED_COUNT, HOTBAR_COUNT);
		inventory.OnInventoryChanged += RefreshUI;

		var canvasGO = new GameObject("InventoryCanvas");
		var canvas = canvasGO.AddComponent<Canvas>();
		canvas.renderMode = RenderMode.ScreenSpaceOverlay;
		var scaler = canvasGO.AddComponent<CanvasScaler>();
		scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
		scaler.referenceResolution = new Vector2(1920, 1080);
		scaler.matchWidthOrHeight = 0.5f;
		canvasGO.AddComponent<GraphicRaycaster>();

		var hotbarPanel = new GameObject("HotbarPanel");
		var hotbarRect = hotbarPanel.AddComponent<RectTransform>();
		hotbarPanel.transform.SetParent(canvasGO.transform, false);
		hotbarRect.anchorMin = new Vector2(0.5f, 0f);
		hotbarRect.anchorMax = new Vector2(0.5f, 0f);
		hotbarRect.pivot = new Vector2(0.5f, 0f);
		hotbarRect.anchoredPosition = new Vector2(0, 10);
		hotbarRect.sizeDelta = new Vector2(600, 80);

		var hLayout = hotbarPanel.AddComponent<HorizontalLayoutGroup>();
		hLayout.spacing = 5;
		hLayout.childAlignment = TextAnchor.MiddleCenter;
		hLayout.childControlWidth = false;
		hLayout.childControlHeight = false;
		hLayout.childForceExpandWidth = false;
		hLayout.childForceExpandHeight = false;
		hLayout.padding = new RectOffset(5, 5, 5, 5);

		hotbarSlots = new InventorySlot[HOTBAR_COUNT];
		for (int i = 0; i < HOTBAR_COUNT; i++)
		{
			hotbarSlots[i] = CreateSlot("HotbarSlot" + i, hotbarPanel.transform, new Vector2(60, 60), i);
		}

		extendedPanel = new GameObject("ExtendedInventoryPanel");
		var extRect = extendedPanel.AddComponent<RectTransform>();
		extendedPanel.AddComponent<CanvasRenderer>();
		var extImage = extendedPanel.AddComponent<Image>();
		extImage.color = new Color(0, 0, 0, 0.8f);
		extendedPanel.transform.SetParent(canvasGO.transform, false);
		extRect.anchorMin = new Vector2(0.5f, 0.5f);
		extRect.anchorMax = new Vector2(0.5f, 0.5f);
		extRect.pivot = new Vector2(0.5f, 0.5f);
		extRect.anchoredPosition = Vector2.zero;
		extRect.sizeDelta = new Vector2(600, 400);

		var grid = extendedPanel.AddComponent<GridLayoutGroup>();
		grid.cellSize = new Vector2(80, 80);
		grid.spacing = new Vector2(10, 10);
		grid.padding = new RectOffset(10, 10, 10, 10);
		grid.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
		grid.constraintCount = 6;
		grid.childAlignment = TextAnchor.MiddleCenter;

		extendedSlots = new InventorySlot[EXTENDED_COUNT];
		for (int i = 0; i < EXTENDED_COUNT; i++)
		{
			int index = HOTBAR_COUNT + i;
			extendedSlots[i] = CreateSlot("ExtendedSlot" + i, extendedPanel.transform, new Vector2(80, 80), index);
		}
		extendedPanel.SetActive(false);

		if (startingItems != null)
		{
			foreach (var itemData in startingItems)
			{
				if (itemData != null) inventory.TryAddItem(itemData);
			}
		}
		RefreshUI();
		UpdateHotbarUI();
	}

	private InventorySlot CreateSlot(string name, Transform parent, Vector2 size, int index)
	{
		var slotGO = new GameObject(name);
		var slotRect = slotGO.AddComponent<RectTransform>();
		slotGO.transform.SetParent(parent, false);
		slotRect.sizeDelta = size;
		var slotBG = slotGO.AddComponent<Image>();
		slotBG.color = Color.gray;
		slotBG.raycastTarget = true;

		var slot = slotGO.AddComponent<InventorySlot>();
		slot.inventoryManager = this;
		slot.slotIndex = index;

		var highlightGO = new GameObject("HighlightBorder");
		var highlightRect = highlightGO.AddComponent<RectTransform>();
		highlightGO.AddComponent<CanvasRenderer>();
		var highlightImg = highlightGO.AddComponent<Image>();
		highlightGO.transform.SetParent(slotGO.transform, false);
		highlightRect.anchorMin = Vector2.zero;
		highlightRect.anchorMax = Vector2.one;
		highlightRect.offsetMin = Vector2.zero;
		highlightRect.offsetMax = Vector2.zero;
		highlightImg.type = Image.Type.Simple;
		highlightImg.color = new Color(1f, 1f, 0f, 0.3f);
		highlightImg.raycastTarget = false;
		highlightImg.enabled = false;
		slot.highLightBorder = highlightImg;

		slot.ClearSlot();
		return slot;
	}

	private void RefreshUI()
	{
		for (int i = 0; i < HOTBAR_COUNT; i++)
		{
			var data = inventory.GetItem(i);
			hotbarSlots[i].SetSlotItemData(data);
		}
		for (int i = 0; i < EXTENDED_COUNT; i++)
		{
			int index = HOTBAR_COUNT + i;
			var data = inventory.GetItem(index);
			extendedSlots[i].SetSlotItemData(data);
		}
	}

	public void ToggleExtendedInventory()
	{
		if (extendedPanel != null) extendedPanel.SetActive(!extendedPanel.activeSelf);
	}

	public void SetSelectedHotbarSlot(int i)
	{
		if (i < 0 || i >= HOTBAR_COUNT) return;
		selectedHotbarSlot = i;
		UpdateHotbarUI();
	}

	private void UpdateHotbarUI()
	{
		for (int i = 0; i < HOTBAR_COUNT; i++)
		{
			hotbarSlots[i].HighlightSlot(i == selectedHotbarSlot);
		}
	}

	public void AddItem(InventoryItemData newItem)
	{
		if (newItem == null) return;
		bool added = inventory.TryAddItem(newItem);
		if (!added) Debug.Log("Inventory full!");
	}

	public InventoryItem GetItemInHotbar(int i)
	{
		if (i < 0 || i >= HOTBAR_COUNT) return null;
		return hotbarSlots[i].currentItem;
	}
	public InventoryItem GetCurrentItem()
	{
		return GetItemInHotbar(selectedHotbarSlot);
	}

	public void SwapSlotItems(int indexA, int indexB)
	{
		inventory.SwapItems(indexA, indexB);
	}
}

================
File: InventoryManger.cs.meta
================
fileFormatVersion: 2
guid: c7dada1471fd1c54381f73579d04d087
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: InventorySlot.cs
================
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class InventorySlot : MonoBehaviour, IDropHandler
{
	public InventoryManager inventoryManager;
	public int slotIndex;
	public InventoryItem currentItem;
	public Image highLightBorder;

	public void SetSlotItemData(InventoryItemData data)
	{
		if (currentItem != null)
		{
			Destroy(currentItem.gameObject);
			currentItem = null;
		}
		if (data == null) return;

		var itemGO = new GameObject("InventoryItem");
		itemGO.transform.SetParent(transform, false);

		var itemImg = itemGO.AddComponent<Image>();
		itemImg.raycastTarget = true;
		itemImg.preserveAspect = true;

		var cg = itemGO.AddComponent<CanvasGroup>();

		var invItem = itemGO.AddComponent<InventoryItem>();
		invItem.Initialize(data);

		currentItem = invItem;
	}

	public void ClearSlot()
	{
		if (currentItem != null)
		{
			Destroy(currentItem.gameObject);
			currentItem = null;
		}
	}

	public void HighlightSlot(bool h)
	{
		if (highLightBorder != null) highLightBorder.enabled = h;
	}

	public void OnDrop(PointerEventData eventData)
	{
		var draggedItem = eventData.pointerDrag?.GetComponent<InventoryItem>();
		if (draggedItem != null)
		{
			var sourceSlot = draggedItem.originalParent?.GetComponent<InventorySlot>();
			if (sourceSlot != null && sourceSlot != this)
			{
				inventoryManager.SwapSlotItems(sourceSlot.slotIndex, slotIndex);
			}
		}
	}

	public void PlaceItem(InventoryItem item)
	{
		var sourceSlot = item.originalParent?.GetComponent<InventorySlot>();
		if (sourceSlot != null && sourceSlot != this)
		{
			inventoryManager.SwapSlotItems(sourceSlot.slotIndex, slotIndex);
		}
	}
}

================
File: InventorySlot.cs.meta
================
fileFormatVersion: 2
guid: 1ba432ac9197e7547bf64953421f9e0a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: PlayerController.cs
================
using UnityEngine;

[RequireComponent(typeof(CharacterController))]
public class PlayerController : MonoBehaviour
{
	private CharacterController controller;
	private InputManager inputManager;
	private PlayerStats playerStats;
	private InventoryManager inventoryManager;
	private bool isInventoryOpen = false;

	[Header("Movement Properties")]
	[SerializeField] private float moveSpeed = 5.0f;
	[SerializeField] private float gravity = -9.81f;
	[SerializeField] private float jumpHeight = 1.5f;
	[SerializeField] private float smoothTimeGrounded = 0.1f;
	[SerializeField] private float smoothTimeAir = 0.3f;

	private Vector3 velocity;
	private Vector3 moveDirection;
	private Vector3 smoothMoveVelocity;

	[Header("Inventory & Held Item")]
	[Tooltip("The parent GameObject under which the held item prefab will be instantiated.")]
	[SerializeField] private GameObject heldItemParent;

	void Start()
	{
		controller = GetComponent<CharacterController>();
		inputManager = GetComponent<InputManager>();
		playerStats = GetComponent<PlayerStats>();
		inventoryManager = GetComponent<InventoryManager>();
		if (controller == null)
			Debug.LogError("CharacterController component not found.");

		if (heldItemParent == null)
			Debug.LogError("HeldItemParent GameObject is not assigned in the Inspector.");


		velocity = Vector3.zero;
		moveDirection = Vector3.zero;
		smoothMoveVelocity = Vector3.zero;

		// Initialize the inventory UI (which will also assign any starting items)
		if (inventoryManager != null)
		{
			inventoryManager.InitializeInventoryUI();
		}
		LockCursor();
	}

	void Update()
	{
		if (isInventoryOpen)
		{
			HandleInventoryInput();
			return;
		}
		if(inputManager.GetUseInput())
		{
			UseSelectedItem();
		}
		HandleHotbarInput();
		HandleInventoryInput();
		HandleMovement();
		HandleMouseLook();
	}
	void HandleInventoryInput()
	{
		if (inputManager.GetInventoryInput())
		{
			isInventoryOpen = !isInventoryOpen;
			if (isInventoryOpen)
			{
				UnlockCursor();
			}
			else
			{
				LockCursor();
			}
			inventoryManager.ToggleExtendedInventory();
		}
	}
	void HandleHotbarInput()
	{
		int slotInput = inputManager.GetHotbarSlotInput();
		if (slotInput != -1)
		{
			SelectHotbarSlot(slotInput);
		}
	}

	void SelectHotbarSlot(int index)
	{
		if (inventoryManager == null)
		{
			Debug.LogError("InventoryManager is not assigned.");
			return;
		}

		// Update the selected slot in the UI
		inventoryManager.SetSelectedHotbarSlot(index);

		// Remove any previously held item
		if (heldItemParent != null)
		{
			foreach (Transform child in heldItemParent.transform)
			{
				Destroy(child.gameObject);
			}
		}
		else
		{
			Debug.LogError("HeldItemParent GameObject is not assigned.");
			return;
		}

		// Get the InventoryItem from the selected slot and instantiate its prefab if available
		InventoryItem selectedItem = inventoryManager.GetItemInHotbar(index);
		if (selectedItem != null &&
			selectedItem.itemData != null &&
			selectedItem.itemData.itemPrefab != null)
		{
			Instantiate(selectedItem.itemData.itemPrefab, heldItemParent.transform);
		}
	}


	void HandleMovement()
	{
		Vector2 movementInput = inputManager.GetMovementInput();
		float moveX = movementInput.x;
		float moveZ = movementInput.y;

		// Calculate target move direction in world space
		Vector3 targetMoveDirection = (transform.right * moveX + transform.forward * moveZ).normalized * moveSpeed;

		// Use different smoothing times based on whether the player is grounded
		float smoothTime = controller.isGrounded ? smoothTimeGrounded : smoothTimeAir;
		moveDirection = Vector3.SmoothDamp(moveDirection, targetMoveDirection, ref smoothMoveVelocity, smoothTime);

		// Handle jumping
		if (inputManager.GetJumpInput() && controller.isGrounded)
		{
			velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);
		}

		// Apply gravity
		velocity.y += gravity * Time.deltaTime;

		// Move the player
		Vector3 finalMoveDirection = moveDirection + Vector3.up * velocity.y;
		controller.Move(finalMoveDirection * Time.deltaTime);
	}

	void HandleMouseLook()
	{
		Vector2 mouseDelta = inputManager.GetMouseLookInput();
		transform.rotation = Quaternion.Euler(transform.eulerAngles.x - mouseDelta.y, transform.eulerAngles.y + mouseDelta.x, 0);
	}
	void LockCursor()
	{
		Cursor.lockState = CursorLockMode.Locked;
		Cursor.visible = false;
	}
	void UnlockCursor()
	{
		Cursor.lockState = CursorLockMode.None;
		Cursor.visible = true;
	}
	void UseSelectedItem()
	{
		// Get the selected item from the inventory
		InventoryItem selectedItem = inventoryManager.GetCurrentItem();
		if (selectedItem == null || selectedItem.itemData == null)
		{
			Debug.Log("No item selected.");
			return;
		}
		Debug.Log("Using item: " + selectedItem.itemData.itemName);
	}
}

================
File: PlayerController.cs.meta
================
fileFormatVersion: 2
guid: fd713551939718148a416f5860877031
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: PlayerStats.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;


public class PlayerStats : MonoBehaviour
{
	[Header("Player Stats")]
	[SerializeField] private float health = 100f;
	[SerializeField] private float hunger = 100f;
	[SerializeField] private float thirst = 100f;
	[SerializeField] private float stamina = 100f;

	public float Health { get => health; set => health = value; }
	public float Hunger { get => hunger; set => hunger = value; }
	public float Thirst { get => thirst; set => thirst = value; }
	public float Stamina { get => stamina; set => stamina = value; }

}

================
File: PlayerStats.cs.meta
================
fileFormatVersion: 2
guid: 5e260809717421c4d8e56a755ca8764e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: StatsBar.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class StatsBar : MonoBehaviour
{
    //This script is purely for debug purposes it will be removed for later builds.
    public Slider healthSlider, staminaSlider, hungerSlider, thirstSlider;
    public Text healthText, staminaText, hungerText, thirstText;
    public GameObject playerState;

    private PlayerStats stats;

    void Awake()
    {

        stats = playerState.GetComponent<PlayerStats>();

        // Set max values
        healthSlider.maxValue = stats.Health;
        staminaSlider.maxValue = stats.Stamina;
        hungerSlider.maxValue = stats.Hunger;
        thirstSlider.maxValue = stats.Thirst;

        // Initialize slider values
        UpdateStatsUI();
    }

    void Update()
    {
        if (stats == null) return;

        
        if (Input.GetKeyDown(KeyCode.N)) stats.Health = Mathf.Max(stats.Health - 10, 0);
        if (Input.GetKeyDown(KeyCode.M)) stats.Stamina = Mathf.Max(stats.Stamina - 10, 0);
        if (Input.GetKeyDown(KeyCode.B)) stats.Hunger = Mathf.Max(stats.Hunger - 10, 0);
        if (Input.GetKeyDown(KeyCode.V)) stats.Thirst = Mathf.Max(stats.Thirst - 10, 0);

        UpdateStatsUI();
    }

    void UpdateStatsUI()
    {
        healthSlider.value = stats.Health;
        staminaSlider.value = stats.Stamina;
        hungerSlider.value = stats.Hunger;
        thirstSlider.value = stats.Thirst;

        if (healthText != null) healthText.text = $"{stats.Health} / {healthSlider.maxValue}";
        if (staminaText != null) staminaText.text = $"{stats.Stamina} / {staminaSlider.maxValue}";
        if (hungerText != null) hungerText.text = $"{stats.Hunger} / {hungerSlider.maxValue}";
        if (thirstText != null) thirstText.text = $"{stats.Thirst} / {thirstSlider.maxValue}";
    }
}

================
File: StatsBar.cs.meta
================
fileFormatVersion: 2
guid: a2c9c4d6a3702764d91b36ce6681d0c5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:



================================================================
End of Codebase
================================================================
